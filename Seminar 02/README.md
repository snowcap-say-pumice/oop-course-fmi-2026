# 02. Kапсулация. Модификатори за достъп. Указател this. Селектори и мутатори. / [Потоци. Четене и писане в текстов файл. `std::print` и `std::format`](https://github.com/StefanShivarov/oop-course-fmi-2026/tree/main/Seminar%2002/streams_textfiles_print_format.md)


### Капсулация (encapsulation)
**Капсулацията** (известно още като "скриване на информация") е един от основните принципи в ООП. Тя налага разбиването на един клас на интерфейс и имплементация.

Интерфейсът представлява набор от операции, които потребителят може да изпълнява свободно по начин, който не "бърка" в имплементацията.

Понякога искаме потребителите да **нямат достъп до всички член-данни и методи на даден клас**.

Това е така, защото тяхната промяна може да доведе до **неочаквано поведение** на нашата програма. Принципът за **капсулация** ни помага като позволява да определим кои методи и атрибути може да използват потребителите на нашия клас.

Капсулацията е механизъм, който ни позволява да скрием имплементацията и да контролираме достъпа до данни/операции чрез модификатори за достъп.

Разделяме класа на:

- public интерфейс – това, което е позволено да се ползва отвън

- private/protected имплементация – детайли, инварианти, помощни функции

### Модификатори за достъп
 
| Модификатор за достъп | Достъп до член-данни                        |
|------------------------|---------------------------------|
| private                | само текущия клас               |
| protected              | текущия клас и *наследниците*.  |
| public                 | отвсякъде                       |

---

#### Разлика между `struct` и `class`

В C++ `struct` и `class` са почти едно и също, разликите са две:

1) Достъп по подразбиране:

    - `struct` → public

    - `class` → private

2) Наследяване по подразбиране _(за това по-нататък)_

    - `struct` → public наследяване

    - `class` → private наследяване

Правило за курса:

- `struct` най-често за “plain data” (малки типове без инварианти)

- `class` за по-комплексни типове с инварианти и капсулация, валидация на данните, логика и тн.

## Член-функции
Член-функциите са функции, които работят с член-данните на обекта от дадена структура.

Можем да имаме **неконстантни** член-функции. В тях можем да променяме член-данни на обекта. НЕ можем да ги извикваме от константни обекти!


```c++

#include <iostream>

class BankAccount {
private:
    double balance = 0.0;

public:
    // non-const member-function: може да променя *this
    bool deposit(double amount) {
        if (amount <= 0.0) return false;
        balance += amount;
        return true;
    }

    bool withdraw(double amount) {
        if (amount <= 0.0) return false;
        if (amount > balance) return false;
        balance -= amount;
        return true;
    }

    //...
};
```

Moжем да имаме и **константни** член-функции. При тях "декларираме", че не променяме член-данните и съответно можем да ги извикваме от константни обекти от дадения клас.

```cpp

class BankAccount {
    // ...

    // const member-function: гарантира, че няма да променя *this
    double getBalance() const {
        return balance;
    }
    // ...
}   
```
  
**Член-функциите**:
 - Работят с член-данните на класа.
 - Извикват се от обект на класа
 - Компилаторът преобразува всяка **член-функция** на дадена структура в
   обикновена функция с уникално име и един допълнителен параметър
   – **константен указател към обекта** (`this`).

### Указател this

Всяка член-функция на обект има достъп до константен указател към обекта, който се нарича `this`.

Неконстантната член функция `bool BankAccount::deposit(double amount);` от горните примери се "превежда" от компилатора по следния начин:

```cpp
// bool deposit(double amount)  --->  bool deposit(BankAccount* const this, double amount)
bool BankAccount::deposit(BankAccount* const this, double amount) {
    if (amount <= 0.0) return false;
    this->balance += amount;
    return true;
}
```

Като забележете, че this е const указател към Point, т.е. не можем да пренасочваме указателя this, но можем да променяме обекта, който е сочен от него (четем декларациите на указателите отдясно наляво).
и съответно

```c++
bankAccount.deposit(5000);
```

се превежда в:

```c++
BankAccount::deposit(&bankAccount, 5000);
```

Константната член-функция `BankAccount::getBalance() const` се свежда до:

```cpp
// double getBalance() const --->  double getBalance(const BankAccount* const this)
double BankAccount::getBalance(const BankAccount* const this) {
    return this->balance;
}
```

Тук указателят `this` сочи към константни данни и съответно не може да променя член-данните.


## Селектори и мутатори

Това са публични член-функции, които се използват за достъпване (get) и промяна (set) на член-данни, които са декларирани в `private`/`protected` секция на един клас.

> *Защо не държим полетата `public`?* - Защото искаме да пазим инварианти (условия, които винаги са верни за валиден обект). Пример: оценка ∈ [2..6], възраст ≥ 0.

**Пример за get-ъри и set-ъри**

```c++
#include <iostream>

struct Student {
private:
	int grade = 2;
	int age = 0; // or some default age
public:
	int getGrade() const {
		return grade;
	}

	int getAge() const {
		return age;
	}

	void setGrade(int grade) {
		if(grade >= 2 && grade <= 6) {
			this->grade = grade;
		}
	}

	void setAge(int age) {
		if(age >= 0) {
			this->age = age;
		}
	}
};
```
---

### Mutable
Спецификатора mutable е приложен само в С++. Той позволява на член на обект да предефинира константността. Така mutable член на const обект не е const и може да бъде изменян. Mutable променливите не променят външното състояние на обекта. Може да се използва в ситуации тип - брояч на достъп и кеширане.

 ```c++
struct Test {
private:
	mutable int n;
public:
	void f() const {
		n++;
	}
};

int main() {
	const Test t;
	t.f(); // this will work, because Test::n is marked as mutable
}
```

> _**Бележка**: Използвайте `mutable` **САМО** в краен случай!_

